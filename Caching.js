# Что такое кэш? В чем разница между кэшем и мемоизацией?
Если упрощать, в том, что кэшированные данные живут в браузере до момента, 
пока не будут принудительно очищены, а мемоизированные данные живут, 
пока не завершен запрос к серверу или сессия пользователя (то есть, в пока не закроется вкладка).





# Как работает fetch в Next
По дефолту все операции fetch — статичные. 
То есть, исполняются на сервере и приходят на клиент в виде HTML-кода без скриптов. 
Эти данные автоматически кэшируются и без обновления страницы с очисткой кэша 
(Ctrl + Shift + R) заново запрашиваться не будут.





# Делаем fetch-операции динамическими
Чтобы каждый раз запрашивать данные принудительно (эмулировать динамически 
обновляемые данные, в нашем случае), мы добавляем в запрос:

const time = await fetch(
	'http://worldtimeapi.org/api/timezone/Europe/Prague', { 
		cache: 'no-store'
	}
)

Кроме того, можно использовать опции Route Segment Config, чтобы 
отказаться от кэширования для определенного адреса (страницы). 
Это повлияет на все fetch-запросы на странице, включая сторонние библиотеки.

export const dynamic = 'force-dynamic'

Ещё один способ работы с динамическими данными — добавить время ревалидации в секундах. 
Пока не пройдёт указанное время, значение будет браться из кэша, 
а затем будет отправлен новый fetch-запрос.

const time = await fetch(
	'http://worldtimeapi.org/api/timezone/Europe/Prague', { 
		next: { 
			revalidate: 5 
		} 
	}
)

В прошлой версии Next, когда использовались Pages, можно было выбрать 
только один способ работы с данными на один путь (страницу): SSR, SSG, ISR. 

В новой версии App можно на одной странице использовать и статичные, и динамические операции.
Но если компонент использует какие-либо динамические данные, он должен быть клиентской ("use client").

Настройки { cache } и { next: { revalidate } } в fetch-запросе работают только с нативным Fetch API, 
при использовании сторонних библиотек вроде Axios они не могут быть использованы. 
Но export const dynamic = 'force-dynamic' будет работать и со сторонними.





# 4 типа кэширования в Next
№  Название              Где используется  Цель
1. Request Memoization   Сервер            Повторное использование данных в дереве React Component
2. Data Cache            Сервер            Хранение данные о запросах пользователей и деплоях
3. Full Route Cache      Сервер            Снижение стоимости рендеринга и повышение производительности
4. Router Cache          Клиент            Снижение количество запросов к серверу при навигации





# Request Memoization
React расширяет Fetch API для автоматической мемоизации запросов с одинаковыми URL и опциями. 
Это означает, что вы можете вызывать функцию fetch для одних и тех же данных в нескольких местах 
в дереве компонентов React, выполняя ее только один раз.

Например, нам нужно получить одно и то же значение в разных частях приложения.
Для этого в папке api у нас сохранена функция getSmth().

async function getSmth() {
  const smth = await fetch('https://.../stuff/1')
  return smth.json()
}

Мы можем вызывать getSmth() где хотим сколько хотим раз — результат первого вызова будет кэширован.

Поскольку Request Memoization — расширение React для конкретно Fetch API, вне функции fetch
она не сработает автоматически. Для этого используется отдельная cache-функция из библиотеки React.

import { cache } from 'react'
import db from '@/lib/db'

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})

Итого: Request Memoization используется до каких-либо пользовательских запросов, в момент
развертывания приложения на сервере, с целью не запрашивать одни и те же данные много раз,
а запросив один раз — сохранить в кэш и забирать оттуда.




# Data Cache 
Next тоже по-своему расширяет Fetch API. Data Cache — это как бы усовершенствование Request Memoization.

# Разница
Жизненный цикл Request Memoization в React заканчивается после обработки 
и вывода всех запросов, необходимых для рендеринга.

Data Cache делает по сути то же самое, но сохраняет кэшированные даннные 
запросов на сервере, пока они не будут ревалидированы.

# Как устроен Data Cache по шагам
1.  При первом вызове запроса fetch во время рендеринга Next проверяет кэш на наличие кэшированного ответа.
2.  Если кэшированный ответ найден, он выводится и мемоизируется (то есть, происходит Request Memoization).
3.  Если кэшированный ответ не найден, выполняется запрос к источнику данных, 
    результат сохраняется в Data Cache и мемоизируется (Request Memoization).
4.  Для некэшированных данных (например, { cache: 'no-store' }) 
    результат всегда извлекается из источника данных и мемоизируется.
5.  Независимо от того, кэшированы данные или нет, запросы всегда мемоизируются, 
    чтобы избежать дублирования запросов к одним и тем же данным во время выполнения рендеринга React.

# 2 вида ревалидации: временная (Time-based) и событийная (On-demand)
Временную мы уже видели. Например, такая будет запрашивать новые данные каждые 5 секунд.

const time = await fetch(
	'http://worldtimeapi.org/api/timezone/Europe/Prague', { 
		next: { 
			revalidate: 5 
		} 
	}
)

Событийная — это ревалидация по пути страницы (revalidatePath) или по тегу кэша (revalidateTag).

#revalidatePath
revalidatePath позволяет вручную ревалидировать данные и ререндерить страницу по указанному адресу.
Используется, например, когда мы добавляем новую запись в базу данных и хотим немедленно отобразить
обновленную страницу в браузере — потому что сам факт обновления БД не вызывает ререндеринг в Next.

revalidatePath('/')

#revalidateTag
При использовании fetch можно пометить записи кэша одним или несколькими тегами.
Затем можно вызвать revalidateTag, чтобы очистить записи кэша, связанные с этим тегом.

fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
revalidateTag('a')

Итого: Data Cache работает так же, как Request Memoization — кэширует данные fetch-запросов, 
чтобы не вызывать одни и те же по многу раз. Но он еще более экономный: Request 
Memoization вызываетсяпо запросу для каждого пользователя (а потом кэш стирается), 
а Data Cache — сохраняет на сервере все данные до ревалидации.





# Full Route Cache и Router Cache
Если упрощать: 
Full Route Cache — это хранение на сервере статически сгенерированных страниц (SSG) в виде 
пререндеренных HTML и React Server Components (RSC, оптимизированный формат данных для потоковой передачи).

Route Cache — это хранение на клиенте полезной информации обо всех отрендеренных страницах, 
а также предсобранных страниц, которые пользователь вероятно посетит.

Чтобы понять это подробнее, стоит рассмотреть сам процесс рендеринга в Next.





# 5 шагов рендеринга компонента в Next
Серверные шаги
1.  React рендерит серверные компоненты в RSC-формат.
2.  Next использует RSC и JavaScript-инструкции клиентских компонентов для рендеринга HTML на сервере.

Это означает, что нам не нужно ждать, пока отрендерится вся страница и соберутся все данные, прежде чем 
показывать страницу (которая на старте будет неинтерактивной) и кэшировать результаты запросов.
Вместо этого Next докидывает данные на страницу по мере их получения — это называется гидратация.

Клиентские шаги
3.  Пользователь получает неинтерактивный HTML с сервера, под капотом продолжается работа.
4.  RSC используется для сравнения деревьев клиентских и серверных компонентов и обновления DOM страницы.
5.  Инструкции JavaScript используются для гидратации клиентских компонентов — это делает приложение интерактивным.



Full Route Cache запускается после 2 шага рендеринга. Результат кэширования остается на сервере,
не меняется и не удаляется, пока не будет создан новый билд или запущена ревалидация.

Full Route Cache можно отключить для отдельных страниц двумя путями:
1.  Использование динамических функций: cookies(), headers(), searchParams(), хук useSearchParams().
    Это сделает страницу/компонент из серверной клиентской.
2.  Использование параметров dynamic = 'force-dynamic' или revalidate = 0. 
    При этом будет пропущен также и Data Cache. Компоненты будут отрисовываться 
    и данные будут собираться заново при каждом входящем запросе к серверу.



Router Cache запускается после 5 шага рендеринга. Результат кэширования хранится на клиенте.

Когда пользователь переходит между адресами страниц, Next кэширует посещенные страницы и предсобирает 
страницы, на которые пользователь, скорее всего, перейдет (на основе компонентов <Link>).

Этот кэш удаляется перезагрузкой со сбросом кэша.

Ранее рассмотренные способы ревалидации данных revalidatePath и revalidateTag
также очистят Router Cache по указанному адресу.



# Различие кэширования статичных и динамических страниц и компонентов
Все серверные компоненты по умолчанию статичные. То есть, если мы добавим в код

new Date().toLocaleTimeString()

то обновляя страницу в режиме разработчика, мы будем видеть новое время.
Но во время билда страница станет статичной, и там всегда будет то время, 
которое было запрошено в тот момент.

Статичные страницы и компоненты рендерятся во время билда 
и кэшируются на сервере по умолчанию.

Динамические страницы и компоненты рендерятся во время пользовательского
запроса и кэшируются в процессе рендеринга.

Если на статичных страницах есть динамичный компонент, 
вся страница воспринимается как динамическая. Но динамический 
рендеринг не означает, что компонент становится клиентским.
